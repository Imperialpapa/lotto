<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>로또 오라클</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Black+Han+Sans&family=Noto+Sans+KR:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #0a0a0f;
            --bg-card: #13131a;
            --bg-surface: #1a1a24;
            --gold: #d4a843;
            --gold-bright: #f0c75e;
            --gold-dim: #8a6d2b;
            --text-primary: #e8e4dc;
            --text-secondary: #8a8690;
            --text-muted: #4a4650;
            --accent-blue: #4a7cff;
            --accent-red: #ff4a6a;
            --accent-green: #3adf7c;
            --glow-gold: rgba(212, 168, 67, 0.3);
            --glow-blue: rgba(74, 124, 255, 0.3);
            --radius-sm: 8px;
            --radius-md: 14px;
            --radius-lg: 22px;
            --radius-xl: 30px;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { font-size: 16px; }

        body {
            font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-deep);
            color: var(--text-primary);
            min-height: 100vh;
            min-height: 100dvh;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
        }

        /* === NOISE TEXTURE OVERLAY === */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.04'/%3E%3C/svg%3E");
            pointer-events: none;
            z-index: 0;
        }

        /* === AMBIENT GLOW === */
        body::after {
            content: '';
            position: fixed;
            top: -30%;
            left: 50%;
            transform: translateX(-50%);
            width: 140vw;
            height: 60vh;
            background: radial-gradient(ellipse, rgba(212, 168, 67, 0.06) 0%, transparent 70%);
            pointer-events: none;
            z-index: 0;
        }

        /* === MAIN SHELL === */
        .shell {
            position: relative;
            z-index: 1;
            max-width: 520px;
            margin: 0 auto;
            padding: 16px 12px env(safe-area-inset-bottom, 16px);
            min-height: 100vh;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
        }

        /* === HEADER === */
        .header {
            text-align: center;
            padding: 24px 0 20px;
        }
        .header h1 {
            font-family: 'Black Han Sans', sans-serif;
            font-size: clamp(1.6rem, 5vw, 2.2rem);
            color: var(--gold-bright);
            letter-spacing: 2px;
            text-shadow: 0 0 30px var(--glow-gold), 0 0 60px rgba(212, 168, 67, 0.15);
            line-height: 1.2;
        }
        .header .subtitle {
            font-size: clamp(0.7rem, 2vw, 0.8rem);
            color: var(--text-muted);
            margin-top: 6px;
            letter-spacing: 4px;
            text-transform: uppercase;
            font-weight: 300;
        }

        /* === CATEGORY TABS === */
        .category-bar {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            padding: 2px 0;
        }
        .category-bar::-webkit-scrollbar { display: none; }
        .cat-tab {
            flex-shrink: 0;
            padding: 7px 14px;
            border-radius: 20px;
            border: 1px solid var(--text-muted);
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-family: 'Noto Sans KR', sans-serif;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.25s ease;
            white-space: nowrap;
            -webkit-tap-highlight-color: transparent;
        }
        .cat-tab.active {
            background: var(--gold);
            color: var(--bg-deep);
            border-color: var(--gold);
            font-weight: 700;
            box-shadow: 0 0 16px var(--glow-gold);
        }
        .cat-tab:not(.active):hover {
            border-color: var(--gold-dim);
            color: var(--gold);
        }

        /* === PICKER SECTION === */
        .controls {
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            padding: 16px;
            border: 1px solid rgba(255,255,255,0.04);
            margin-bottom: 14px;
        }
        .picker-row {
            display: flex;
            gap: 10px;
        }
        .picker-wrapper { flex: 1; min-width: 0; }
        .picker-wrapper.small { flex: 0 0 76px; }
        .picker-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 500;
        }
        .picker-container {
            position: relative;
            height: 140px;
            overflow: hidden;
            background: var(--bg-surface);
            border-radius: var(--radius-md);
            border: 1px solid rgba(255,255,255,0.03);
        }
        .picker-highlight {
            position: absolute;
            top: 50%;
            left: 6px; right: 6px;
            height: 38px;
            transform: translateY(-50%);
            background: linear-gradient(90deg, rgba(212,168,67,0.12), rgba(212,168,67,0.06));
            border-radius: 8px;
            pointer-events: none;
            border: 1px solid rgba(212,168,67,0.2);
        }
        .picker-scroll {
            height: 100%;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
            -webkit-overflow-scrolling: touch;
            padding: 51px 0;
        }
        .picker-scroll::-webkit-scrollbar { display: none; }
        .picker-item {
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            scroll-snap-align: center;
            font-size: 0.82rem;
            color: var(--text-muted);
            transition: all 0.2s ease;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            padding: 0 4px;
        }
        .picker-item.active {
            color: var(--gold-bright);
            font-weight: 700;
            font-size: 0.88rem;
            text-shadow: 0 0 12px var(--glow-gold);
        }

        /* === METHOD INFO TOOLTIP === */
        .method-info {
            margin-top: 10px;
            padding: 10px 14px;
            background: rgba(212,168,67,0.05);
            border-radius: var(--radius-sm);
            border-left: 3px solid var(--gold-dim);
            font-size: 0.72rem;
            color: var(--text-secondary);
            line-height: 1.5;
            transition: all 0.3s ease;
        }

        /* === GENERATE BUTTON === */
        .gen-btn {
            display: block;
            width: 100%;
            padding: 16px;
            margin-bottom: 14px;
            border: none;
            border-radius: var(--radius-md);
            background: linear-gradient(135deg, var(--gold) 0%, var(--gold-dim) 100%);
            color: var(--bg-deep);
            font-family: 'Black Han Sans', sans-serif;
            font-size: clamp(1rem, 3vw, 1.2rem);
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
            -webkit-tap-highlight-color: transparent;
            position: relative;
            overflow: hidden;
        }
        .gen-btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.6s ease;
        }
        .gen-btn:hover::before { left: 100%; }
        .gen-btn:hover {
            box-shadow: 0 4px 30px var(--glow-gold), 0 0 60px rgba(212,168,67,0.15);
            transform: translateY(-1px);
        }
        .gen-btn:active {
            transform: scale(0.98);
            box-shadow: 0 2px 10px var(--glow-gold);
        }

        /* === RESULTS AREA === */
        .results {
            flex: 1;
            background: var(--bg-card);
            border-radius: var(--radius-lg);
            border: 1px solid rgba(255,255,255,0.04);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .results-header {
            padding: 12px 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.04);
        }
        .results-header span {
            font-size: 0.7rem;
            color: var(--text-muted);
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: 500;
        }
        .clear-btn {
            background: none;
            border: 1px solid var(--text-muted);
            color: var(--text-muted);
            font-size: 0.65rem;
            padding: 4px 10px;
            border-radius: 12px;
            cursor: pointer;
            font-family: 'Noto Sans KR', sans-serif;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
        }
        .clear-btn:hover {
            border-color: var(--accent-red);
            color: var(--accent-red);
        }
        .results-scroll {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            max-height: 400px;
            scroll-behavior: smooth;
        }
        .results-scroll::-webkit-scrollbar { width: 4px; }
        .results-scroll::-webkit-scrollbar-track { background: transparent; }
        .results-scroll::-webkit-scrollbar-thumb { background: var(--text-muted); border-radius: 2px; }

        .result-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            color: var(--text-muted);
            font-size: 0.8rem;
        }
        .result-empty .icon {
            font-size: 2rem;
            margin-bottom: 10px;
            opacity: 0.4;
        }

        /* === SINGLE SET === */
        .set {
            padding: 14px;
            margin-bottom: 8px;
            background: var(--bg-surface);
            border-radius: var(--radius-md);
            border: 1px solid rgba(255,255,255,0.03);
            animation: setReveal 0.4s ease backwards;
        }
        @keyframes setReveal {
            from { opacity: 0; transform: translateY(12px) scale(0.97); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        .set-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .set-header strong {
            font-size: 0.8rem;
            color: var(--gold);
            font-weight: 700;
        }
        .set-header .method-tag {
            font-size: 0.6rem;
            color: var(--text-muted);
            background: rgba(255,255,255,0.04);
            padding: 3px 8px;
            border-radius: 10px;
            letter-spacing: 0.5px;
        }
        .numbers {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        /* === NUMBER BALLS === */
        .ball {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 0.9rem;
            color: #fff;
            position: relative;
            text-shadow: 0 1px 3px rgba(0,0,0,0.4);
            animation: ballPop 0.35s cubic-bezier(0.34, 1.56, 0.64, 1) backwards;
            transition: transform 0.2s ease;
            cursor: default;
        }
        .ball:hover { transform: scale(1.12); }
        .ball::after {
            content: '';
            position: absolute;
            top: 5px; left: 8px;
            width: 10px; height: 6px;
            background: rgba(255,255,255,0.35);
            border-radius: 50%;
            transform: rotate(-20deg);
        }
        @keyframes ballPop {
            from { opacity: 0; transform: scale(0.3) rotate(-20deg); }
            to { opacity: 1; transform: scale(1) rotate(0); }
        }

        /* Range colors */
        .ball[data-range="1"] {
            background: linear-gradient(145deg, #ffd43b, #e67e22);
            box-shadow: 0 4px 16px rgba(255, 212, 59, 0.35);
        }
        .ball[data-range="2"] {
            background: linear-gradient(145deg, #74b9ff, #2d6cdf);
            box-shadow: 0 4px 16px rgba(74, 124, 255, 0.35);
        }
        .ball[data-range="3"] {
            background: linear-gradient(145deg, #ff7979, #c0392b);
            box-shadow: 0 4px 16px rgba(255, 74, 106, 0.3);
        }
        .ball[data-range="4"] {
            background: linear-gradient(145deg, #a29bfe, #6c5ce7);
            box-shadow: 0 4px 16px rgba(108, 92, 231, 0.35);
        }
        .ball[data-range="5"] {
            background: linear-gradient(145deg, #55efc4, #00b894);
            box-shadow: 0 4px 16px rgba(0, 184, 148, 0.35);
        }

        /* === SPONSOR === */
        .sponsor {
            margin-top: 14px;
            padding: 14px;
            background: linear-gradient(135deg, rgba(212,168,67,0.08), rgba(212,168,67,0.03));
            border-radius: var(--radius-md);
            border: 1px solid rgba(212,168,67,0.15);
            text-align: center;
        }
        .sponsor-title {
            font-size: 0.7rem;
            color: var(--gold);
            font-weight: 700;
            margin-bottom: 3px;
        }
        .sponsor-detail {
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        /* === RESPONSIVE === */
        @media (min-width: 540px) {
            .shell { padding: 24px 20px; }
            .ball { width: 48px; height: 48px; font-size: 1rem; }
            .numbers { gap: 10px; }
        }

        @media (max-width: 380px) {
            .shell { padding: 10px 8px; }
            .controls { padding: 12px; }
            .ball { width: 36px; height: 36px; font-size: 0.78rem; }
            .numbers { gap: 6px; }
            .cat-tab { padding: 6px 10px; font-size: 0.68rem; }
            .picker-container { height: 120px; }
            .picker-scroll { padding: 41px 0; }
        }

        @media (max-height: 600px) and (orientation: landscape) {
            .header { padding: 10px 0; }
            .header h1 { font-size: 1.3rem; }
            .results-scroll { max-height: 200px; }
            .gen-btn { padding: 12px; }
        }

        @media (min-width: 768px) {
            .results-scroll { max-height: 500px; }
        }

        /* === DARK SCROLLBAR GLOBAL === */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--text-muted) transparent;
        }
    </style>
</head>
<body>

<div class="shell">
    <header class="header">
        <h1>LOTTO ORACLE</h1>
        <div class="subtitle">통계 기반 번호 생성기</div>
    </header>

    <!-- Category Tabs -->
    <div class="category-bar" id="categoryBar">
        <button class="cat-tab active" data-cat="basic">기본</button>
        <button class="cat-tab" data-cat="frequency">빈도/간격</button>
        <button class="cat-tab" data-cat="pattern">패턴</button>
        <button class="cat-tab" data-cat="advanced">고급 통계</button>
        <button class="cat-tab" data-cat="filter">필터링</button>
    </div>

    <!-- Controls -->
    <div class="controls">
        <div class="picker-row">
            <div class="picker-wrapper">
                <div class="picker-label">생성 방법</div>
                <div class="picker-container">
                    <div class="picker-highlight"></div>
                    <div class="picker-scroll" id="methodPicker"></div>
                </div>
            </div>
            <div class="picker-wrapper small">
                <div class="picker-label">세트</div>
                <div class="picker-container">
                    <div class="picker-highlight"></div>
                    <div class="picker-scroll" id="setCountPicker"></div>
                </div>
            </div>
        </div>
        <div class="method-info" id="methodInfo">방법을 선택하세요</div>
    </div>

    <!-- Generate Button -->
    <button class="gen-btn" id="genBtn" onclick="generate()">번호 생성</button>

    <!-- Results -->
    <div class="results">
        <div class="results-header">
            <span>생성 결과</span>
            <button class="clear-btn" onclick="clearResults()">초기화</button>
        </div>
        <div class="results-scroll" id="resultsScroll">
            <div class="result-empty" id="emptyState">
                <div class="icon">&#x2728;</div>
                <div>생성된 번호가 여기에 표시됩니다</div>
            </div>
        </div>
    </div>

    <!-- Sponsor -->
    <div class="sponsor">
        <div class="sponsor-title">후원 계좌: 카카오뱅크 3333-35-8084358</div>
        <div class="sponsor-detail">에듀크립트 솔루션즈</div>
    </div>
</div>

<script>
// ========== HISTORICAL DATA (실제 한국 로또 6/45 당첨번호) ==========
const HISTORY = [
    [3,12,18,24,30,43],[2,7,12,22,26,37],[7,11,20,30,39,43],[2,3,14,28,37,45],[6,7,14,18,29,44],
    [2,6,10,23,25,45],[3,9,17,19,43,44],[7,10,14,18,37,43],[1,4,7,15,38,45],[2,8,25,27,37,39],
    [13,19,22,28,34,44],[7,8,20,28,33,45],[2,15,19,24,34,43],[4,9,11,20,28,34],[6,14,17,27,30,42],
    [7,10,16,18,28,45],[6,14,16,21,22,43],[5,10,11,17,28,34],[9,12,20,23,34,40],[6,7,22,32,37,40],
    [3,5,21,24,26,42],[16,19,21,25,26,44],[6,8,14,22,30,44],[4,12,14,28,32,33],[7,11,24,28,35,45],
    [2,9,16,36,38,42],[5,12,25,26,33,44],[8,15,17,19,43,44],[7,10,22,28,34,40],[1,5,22,25,27,32],
    [1,12,20,25,30,45],[3,7,15,29,40,44],[3,11,15,27,29,45],[6,17,19,21,36,43],[1,2,11,28,36,45],
    [6,14,25,27,37,45],[3,10,23,29,33,45],[3,5,17,23,24,35],[3,15,23,24,25,44],[9,12,13,19,37,45],
    [1,3,23,24,27,40],[4,11,16,30,33,44],[7,9,14,18,22,28],[4,12,17,28,38,45],[6,10,16,28,34,44],
    [7,15,16,21,29,44],[6,9,11,17,24,45],[1,7,10,22,26,43],[1,2,4,7,36,45],[5,6,11,19,28,43],
    [3,10,13,22,42,45],[8,10,18,20,24,43],[6,13,27,30,39,40],[6,12,19,22,31,45],[5,6,7,16,17,28],
    [5,9,13,23,39,45],[3,4,8,20,34,44],[4,9,28,32,38,42],[8,11,13,28,36,42],[2,3,22,27,28,41],
    [7,12,13,18,29,45],[4,14,16,21,35,44],[1,10,18,31,33,44],[3,13,16,18,32,45],[5,9,27,33,35,43],
    [3,10,11,15,20,30],[6,13,16,22,43,45],[3,10,11,16,36,44],[3,13,20,28,33,45],[1,3,8,15,34,44],
    [6,11,16,19,22,27],[4,7,12,14,22,38],[7,8,12,21,30,40],[12,21,24,30,37,43],[2,4,10,23,28,41],
    [3,5,6,10,22,26],[2,11,15,16,27,34],[4,16,17,21,29,44],[3,7,10,12,27,41],[4,6,7,37,38,43],
    [5,8,18,21,24,36],[3,5,15,16,33,45],[4,5,17,18,31,43],[2,8,10,25,29,45],[6,11,32,34,40,45],
    [3,7,17,21,22,44],[2,5,7,10,13,44],[4,7,17,18,38,43],[2,14,20,27,39,42],[1,5,20,25,28,45],
    [1,3,7,28,35,42],[5,11,20,33,39,43],[4,8,13,22,28,44],[9,12,14,26,36,45],[7,11,13,15,22,44],
    [3,6,7,14,27,35],[2,6,12,19,22,43],[4,7,9,14,21,44],[3,12,15,24,30,44],[6,8,23,27,38,43],
    [2,5,10,17,24,30],[7,11,22,33,39,45]
];

// ========== STATISTICAL ENGINES ==========
const Stats = {
    // 전체 빈도 계산
    getFrequencies() {
        const freq = new Array(46).fill(0);
        HISTORY.forEach(draw => draw.forEach(n => freq[n]++));
        return freq;
    },

    // 최근 N회차 빈도
    getRecentFreq(n = 20) {
        const freq = new Array(46).fill(0);
        HISTORY.slice(0, n).forEach(draw => draw.forEach(num => freq[num]++));
        return freq;
    },

    // 마지막 출현 간격
    getGaps() {
        const gaps = new Array(46).fill(HISTORY.length);
        for (let i = 0; i < HISTORY.length; i++) {
            HISTORY[i].forEach(n => { if (gaps[n] === HISTORY.length) gaps[n] = i; });
        }
        return gaps;
    },

    // 동반 출현 쌍 빈도
    getPairFreq() {
        const pairs = {};
        HISTORY.forEach(draw => {
            for (let i = 0; i < draw.length; i++) {
                for (let j = i + 1; j < draw.length; j++) {
                    const key = draw[i] + ',' + draw[j];
                    pairs[key] = (pairs[key] || 0) + 1;
                }
            }
        });
        return pairs;
    },

    // 이동평균 (최근 windowSize 회차)
    getMovingAvg(windowSize = 15) {
        const scores = new Array(46).fill(0);
        const recent = HISTORY.slice(0, windowSize);
        recent.forEach((draw, i) => {
            const weight = (windowSize - i) / windowSize;
            draw.forEach(n => scores[n] += weight);
        });
        return scores;
    },

    // AC값 계산
    calcAC(nums) {
        const diffs = new Set();
        for (let i = 0; i < nums.length; i++) {
            for (let j = i + 1; j < nums.length; j++) {
                diffs.add(Math.abs(nums[i] - nums[j]));
            }
        }
        return diffs.size - (nums.length - 1);
    },

    // 엔트로피 점수 (다양성)
    entropyScore(nums) {
        const sorted = [...nums].sort((a, b) => a - b);
        let score = 0;
        // 구간 분포
        const ranges = [0, 0, 0, 0, 0];
        sorted.forEach(n => {
            if (n <= 10) ranges[0]++;
            else if (n <= 20) ranges[1]++;
            else if (n <= 30) ranges[2]++;
            else if (n <= 40) ranges[3]++;
            else ranges[4]++;
        });
        score += ranges.filter(r => r > 0).length * 2;
        // 홀짝 균형
        const odds = sorted.filter(n => n % 2 === 1).length;
        score += (3 - Math.abs(3 - odds)) * 1.5;
        // 간격 다양성
        for (let i = 1; i < sorted.length; i++) {
            score += Math.min(sorted[i] - sorted[i - 1], 10) * 0.3;
        }
        return score;
    },

    // 패턴 검증 (배제 전략용)
    isValidPattern(nums) {
        const sorted = [...nums].sort((a, b) => a - b);
        // 모두 홀수 or 모두 짝수 배제
        const odds = sorted.filter(n => n % 2 === 1).length;
        if (odds === 0 || odds === 6) return false;
        // 모두 같은 10단위 배제
        const decades = new Set(sorted.map(n => Math.floor((n - 1) / 10)));
        if (decades.size === 1) return false;
        // 연속 4개 이상 배제
        let consec = 1;
        for (let i = 1; i < sorted.length; i++) {
            if (sorted[i] === sorted[i - 1] + 1) { consec++; if (consec >= 4) return false; }
            else consec = 1;
        }
        // 합계 범위 (극단 제외)
        const sum = sorted.reduce((a, b) => a + b, 0);
        if (sum < 60 || sum > 220) return false;
        return true;
    },

    // 가중 랜덤 선택
    weightedPick(weights, count, exclude = new Set()) {
        const result = new Set();
        const available = [];
        for (let i = 1; i <= 45; i++) {
            if (!exclude.has(i) && weights[i] > 0) {
                available.push({ num: i, weight: weights[i] });
            }
        }
        while (result.size < count && available.length > 0) {
            const total = available.reduce((s, a) => s + a.weight, 0);
            let r = Math.random() * total;
            for (let k = 0; k < available.length; k++) {
                r -= available[k].weight;
                if (r <= 0) {
                    result.add(available[k].num);
                    available.splice(k, 1);
                    break;
                }
            }
        }
        // fallback
        while (result.size < count) {
            const n = Math.floor(Math.random() * 45) + 1;
            if (!result.has(n)) result.add(n);
        }
        return [...result];
    }
};

// ========== GENERATION METHODS ==========
const generators = {
    '90': {
        name: '90번 방법',
        desc: '2~90의 난수를 2로 나눈 뒤 올림하여 1~45 번호를 생성합니다.',
        fn() {
            const nums = new Set();
            while (nums.size < 6) {
                const n = Math.floor(Math.random() * 89) + 2;
                nums.add(Math.ceil(n / 2));
            }
            return [...nums];
        }
    },
    random: {
        name: '랜덤',
        desc: '1~45에서 6개를 완전 무작위로 선택합니다.',
        fn() {
            const nums = new Set();
            while (nums.size < 6) nums.add(Math.floor(Math.random() * 45) + 1);
            return [...nums];
        }
    },
    oddeven: {
        name: '홀짝 균형',
        desc: '홀수 3개, 짝수 3개를 균등하게 선택합니다. 역대 가장 빈출 비율입니다.',
        fn() {
            const odds = new Set(), evens = new Set();
            while (odds.size < 3) { const n = Math.floor(Math.random() * 23) * 2 + 1; if (n <= 45) odds.add(n); }
            while (evens.size < 3) { evens.add(Math.floor(Math.random() * 22) * 2 + 2); }
            return [...odds, ...evens];
        }
    },
    highlow: {
        name: '고저 균형',
        desc: '저번호(1~22) 3개, 고번호(23~45) 3개를 균등하게 선택합니다.',
        fn() {
            const lows = new Set(), highs = new Set();
            while (lows.size < 3) lows.add(Math.floor(Math.random() * 22) + 1);
            while (highs.size < 3) highs.add(Math.floor(Math.random() * 23) + 23);
            return [...lows, ...highs];
        }
    },
    section: {
        name: '번호대 분산',
        desc: '1~9, 10~19, 20~29, 30~39, 40~45 각 구간에서 1개씩 + 랜덤 1개를 뽑습니다.',
        fn() {
            const sections = [[1,9],[10,19],[20,29],[30,39],[40,45]];
            const used = new Set();
            const nums = [];
            sections.forEach(([min, max]) => {
                let n;
                do { n = Math.floor(Math.random() * (max - min + 1)) + min; } while (used.has(n));
                used.add(n); nums.push(n);
            });
            let extra;
            do { extra = Math.floor(Math.random() * 45) + 1; } while (used.has(extra));
            nums.push(extra);
            return nums;
        }
    },
    frequency: {
        name: '빈도 분석',
        desc: '역대 당첨 데이터에서 자주 출현한 번호(핫 넘버)에 가중치를 두어 선택합니다.',
        fn() {
            const freq = Stats.getFrequencies();
            return Stats.weightedPick(freq, 6);
        }
    },
    gap: {
        name: '간격 분석',
        desc: '오랫동안 출현하지 않은 번호(콜드 넘버)를 우선 선택합니다. 회귀 기대 전략.',
        fn() {
            const gaps = Stats.getGaps();
            const weights = new Array(46).fill(0);
            for (let i = 1; i <= 45; i++) weights[i] = gaps[i] + 1;
            return Stats.weightedPick(weights, 6);
        }
    },
    association: {
        name: '연관 규칙',
        desc: '역대 데이터에서 자주 함께 출현한 번호 쌍을 기반으로 조합을 구성합니다.',
        fn() {
            const pairs = Stats.getPairFreq();
            const sorted = Object.entries(pairs).sort((a, b) => b[1] - a[1]);
            const result = new Set();
            for (const [key] of sorted) {
                if (result.size >= 6) break;
                const [a, b] = key.split(',').map(Number);
                if (result.size < 5) { result.add(a); result.add(b); }
                else if (result.size === 5) { if (!result.has(a)) result.add(a); else if (!result.has(b)) result.add(b); }
            }
            while (result.size < 6) result.add(Math.floor(Math.random() * 45) + 1);
            return [...result].slice(0, 6);
        }
    },
    poisson: {
        name: '확률 분포',
        desc: '포아송 분포 기반으로 기대값 대비 출현이 적은(과소 출현) 번호를 선택합니다.',
        fn() {
            const freq = Stats.getFrequencies();
            const total = HISTORY.length;
            const expected = total * 6 / 45;
            const weights = new Array(46).fill(0);
            for (let i = 1; i <= 45; i++) {
                const deviation = expected - freq[i];
                weights[i] = Math.max(0.1, deviation + expected);
            }
            return Stats.weightedPick(weights, 6);
        }
    },
    movingavg: {
        name: '이동평균',
        desc: '최근 15회차의 가중 이동평균을 계산하여 상승 추세인 번호를 선택합니다.',
        fn() {
            const recent = Stats.getMovingAvg(15);
            const older = Stats.getMovingAvg(30);
            const trend = new Array(46).fill(0);
            for (let i = 1; i <= 45; i++) {
                trend[i] = Math.max(0.1, recent[i] * 2 - older[i] + 1);
            }
            return Stats.weightedPick(trend, 6);
        }
    },
    sumrange: {
        name: '합계 범위',
        desc: '당첨번호 합계의 최빈 구간(100~175)에 맞는 조합만 선택합니다.',
        fn() {
            let attempts = 0;
            while (attempts < 5000) {
                attempts++;
                const nums = new Set();
                while (nums.size < 6) nums.add(Math.floor(Math.random() * 45) + 1);
                const arr = [...nums];
                const sum = arr.reduce((a, b) => a + b, 0);
                if (sum >= 100 && sum <= 175) return arr;
            }
            const nums = new Set();
            while (nums.size < 6) nums.add(Math.floor(Math.random() * 45) + 1);
            return [...nums];
        }
    },
    montecarlo: {
        name: '몬테카를로',
        desc: '10,000회 시뮬레이션을 돌려 역대 분포 패턴과 가장 유사한 조합을 선택합니다.',
        fn() {
            const freq = Stats.getFrequencies();
            const totalNums = HISTORY.length * 6;
            const idealDist = freq.map(f => f / totalNums);
            let bestSet = null, bestScore = Infinity;

            for (let trial = 0; trial < 10000; trial++) {
                const nums = new Set();
                while (nums.size < 6) nums.add(Math.floor(Math.random() * 45) + 1);
                const arr = [...nums];
                let score = 0;
                arr.forEach(n => { score += Math.abs(idealDist[n] - (1 / 45)); });
                // 부가 점수: AC값, 합계 범위, 홀짝
                const sum = arr.reduce((a, b) => a + b, 0);
                if (sum < 100 || sum > 175) score += 0.5;
                const ac = Stats.calcAC(arr);
                if (ac < 7 || ac > 10) score += 0.3;
                if (score < bestScore) { bestScore = score; bestSet = arr; }
            }
            return bestSet || generators.random.fn();
        }
    },
    entropy: {
        name: '엔트로피 기반',
        desc: '정보 엔트로피(다양성)를 최대화하는 조합을 선택합니다. 편중 없는 분산 전략.',
        fn() {
            let bestSet = null, bestScore = -Infinity;
            for (let trial = 0; trial < 5000; trial++) {
                const nums = new Set();
                while (nums.size < 6) nums.add(Math.floor(Math.random() * 45) + 1);
                const arr = [...nums];
                const score = Stats.entropyScore(arr);
                if (score > bestScore) { bestScore = score; bestSet = arr; }
            }
            return bestSet || generators.random.fn();
        }
    },
    elimination: {
        name: '배제 전략',
        desc: '통계적으로 비현실적인 패턴(올홀, 올짝, 연속4+, 극단합 등)을 배제합니다.',
        fn() {
            let attempts = 0;
            while (attempts < 10000) {
                attempts++;
                const nums = new Set();
                while (nums.size < 6) nums.add(Math.floor(Math.random() * 45) + 1);
                const arr = [...nums];
                if (Stats.isValidPattern(arr)) return arr;
            }
            return generators.random.fn();
        }
    },
    acvalue: {
        name: 'AC값 최적화',
        desc: 'AC값(산술복잡도) 7~10 범위의 조합만 선택합니다. 역대 당첨의 80%가 이 범위.',
        fn() {
            let attempts = 0;
            while (attempts < 10000) {
                attempts++;
                const nums = new Set();
                while (nums.size < 6) nums.add(Math.floor(Math.random() * 45) + 1);
                const arr = [...nums].sort((a, b) => a - b);
                const ac = Stats.calcAC(arr);
                if (ac >= 7 && ac <= 10 && Stats.isValidPattern(arr)) return arr;
            }
            return generators.random.fn();
        }
    }
};

// ========== CATEGORY -> METHOD MAPPING ==========
const categories = {
    basic: ['90', 'random', 'oddeven', 'highlow', 'section'],
    frequency: ['frequency', 'gap', 'movingavg'],
    pattern: ['association', 'oddeven', 'section'],
    advanced: ['poisson', 'montecarlo', 'entropy', 'acvalue'],
    filter: ['sumrange', 'elimination', 'acvalue']
};

let currentCategory = 'basic';
let selectedMethod = '90';
let selectedSetCount = 4;
let methodPickerInstance = null;

// ========== CATEGORY TAB LOGIC ==========
document.querySelectorAll('.cat-tab').forEach(tab => {
    tab.addEventListener('click', () => {
        document.querySelectorAll('.cat-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        currentCategory = tab.dataset.cat;
        rebuildMethodPicker();
    });
});

function rebuildMethodPicker() {
    const keys = categories[currentCategory];
    const options = keys.map(k => ({ value: k, label: generators[k].name }));
    selectedMethod = options[0].value;
    updateMethodInfo();
    createCircularPicker('methodPicker', options, 0, val => {
        selectedMethod = val;
        updateMethodInfo();
    });
}

function updateMethodInfo() {
    const info = document.getElementById('methodInfo');
    const gen = generators[selectedMethod];
    if (gen) info.textContent = gen.desc;
}

// ========== CIRCULAR PICKER ==========
function createCircularPicker(elementId, options, defaultIndex, onSelect) {
    const picker = document.getElementById(elementId);
    const itemHeight = 38;
    const itemCount = options.length;
    const cloneCount = Math.min(3, itemCount);
    let selectedValue = options[defaultIndex].value;
    let isScrolling = false;

    picker.innerHTML = '';

    for (let i = itemCount - cloneCount; i < itemCount; i++) {
        const div = document.createElement('div');
        div.className = 'picker-item clone';
        div.dataset.value = options[i].value;
        div.dataset.realIndex = i;
        div.textContent = options[i].label;
        picker.appendChild(div);
    }
    options.forEach((opt, i) => {
        const div = document.createElement('div');
        div.className = 'picker-item';
        div.dataset.value = opt.value;
        div.dataset.realIndex = i;
        div.textContent = opt.label;
        picker.appendChild(div);
    });
    for (let i = 0; i < cloneCount; i++) {
        const div = document.createElement('div');
        div.className = 'picker-item clone';
        div.dataset.value = options[i].value;
        div.dataset.realIndex = i;
        div.textContent = options[i].label;
        picker.appendChild(div);
    }

    const items = picker.querySelectorAll('.picker-item');

    function updateActive() {
        const scrollTop = picker.scrollTop;
        const centerIndex = Math.round(scrollTop / itemHeight);
        items.forEach((item, index) => {
            if (index === centerIndex) {
                item.classList.add('active');
                selectedValue = item.dataset.value;
                onSelect(selectedValue);
            } else {
                item.classList.remove('active');
            }
        });
    }

    function handleScroll() {
        if (isScrolling) return;
        const scrollTop = picker.scrollTop;
        if (scrollTop < (cloneCount - 1) * itemHeight) {
            isScrolling = true;
            picker.scrollTop = scrollTop + itemCount * itemHeight;
            setTimeout(() => isScrolling = false, 50);
        } else if (scrollTop > (cloneCount + itemCount - 1) * itemHeight) {
            isScrolling = true;
            picker.scrollTop = scrollTop - itemCount * itemHeight;
            setTimeout(() => isScrolling = false, 50);
        }
        updateActive();
    }

    picker.addEventListener('scroll', handleScroll);
    items.forEach(item => {
        item.addEventListener('click', () => {
            const realIndex = parseInt(item.dataset.realIndex);
            picker.scrollTo({ top: (cloneCount + realIndex) * itemHeight, behavior: 'smooth' });
        });
    });

    setTimeout(() => {
        picker.scrollTop = (cloneCount + defaultIndex) * itemHeight;
        updateActive();
    }, 50);

    return () => selectedValue;
}

// ========== SET COUNT PICKER ==========
const setCounts = [];
for (let i = 1; i <= 10; i++) setCounts.push({ value: i, label: i + '세트' });
createCircularPicker('setCountPicker', setCounts, 3, val => selectedSetCount = parseInt(val));

// ========== INIT METHOD PICKER ==========
rebuildMethodPicker();

// ========== GENERATE ==========
function generate() {
    const gen = generators[selectedMethod];
    if (!gen) return;

    const emptyState = document.getElementById('emptyState');
    if (emptyState) emptyState.remove();

    const container = document.getElementById('resultsScroll');
    const getRange = n => { if (n <= 10) return '1'; if (n <= 20) return '2'; if (n <= 30) return '3'; if (n <= 40) return '4'; return '5'; };

    for (let set = 1; set <= selectedSetCount; set++) {
        const nums = gen.fn().sort((a, b) => a - b);
        const setEl = document.createElement('div');
        setEl.className = 'set';
        setEl.style.animationDelay = (set - 1) * 0.08 + 's';

        setEl.innerHTML = `
            <div class="set-header">
                <strong>${set}세트</strong>
                <span class="method-tag">${gen.name}</span>
            </div>
            <div class="numbers">
                ${nums.map((n, i) => `<span class="ball" data-range="${getRange(n)}" style="animation-delay:${(set - 1) * 0.08 + i * 0.06}s">${n}</span>`).join('')}
            </div>
        `;
        container.insertBefore(setEl, container.firstChild);
    }

    // Scroll to top
    container.scrollTop = 0;

    // Button feedback
    const btn = document.getElementById('genBtn');
    btn.textContent = '생성 완료!';
    btn.style.background = 'linear-gradient(135deg, var(--accent-green), #1a8a4a)';
    setTimeout(() => {
        btn.textContent = '번호 생성';
        btn.style.background = '';
    }, 800);
}

function clearResults() {
    const container = document.getElementById('resultsScroll');
    container.innerHTML = `
        <div class="result-empty" id="emptyState">
            <div class="icon">&#x2728;</div>
            <div>생성된 번호가 여기에 표시됩니다</div>
        </div>
    `;
}
</script>
</body>
</html>
